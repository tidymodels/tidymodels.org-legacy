{
  "hash": "e5bfdc078ca2199dc3e07b6825658dda",
  "result": {
    "markdown": "---\ntitle: \"How to create a tuning parameter function\"\ncategories:\n  - developer tools\ntype: learn-subsection\nweight: 4\ndescription: | \n  Build functions to use in tuning both quantitative and qualitative parameters.\ntoc: true\ntoc-depth: 2\ninclude-after-body: ../../../resources.html\n---\n\n\n\n\n\n\n## Introduction\n\nTo use code in this article,  you will need to install the following packages: dials and scales.\n\nSome models and recipe steps contain parameters that dials does not know about. You can construct new quantitative and qualitative parameters using `new_quant_param()` or `new_qual_param()`, respectively. This article is a guide to creating new parameters.\n\n## Quantitative parameters\n\nAs an example, let's consider the multivariate adaptive regression spline ([MARS](https://en.wikipedia.org/wiki/Multivariate_adaptive_regression_spline)) model, which creates nonlinear features from predictors and adds them to a linear regression models. The earth package is an excellent implementation of this method.\n\nMARS creates an initial set of features and then prunes them back to an appropriate size. This can be done automatically by `earth::earth()` or the number of final terms can be set by the user. The parsnip function `mars()` has a parameter called `num_terms` that defines this.\n\nWhat if we want to create a parameter for the number of *initial terms* included in the model. There is no argument in `parsnip::mars()` for this but we will make one now. The argument name in `earth::earth()` is `nk`, which is not very descriptive. Our parameter will be called `num_initial_terms`.\n\nWe use the `new_quant_param()` function since this is a numeric parameter. The main two arguments to a numeric parameter function are `range` and `trans`.\n\nThe `range` specifies the possible values of the parameter. For our example, a minimal value might be one or two. What is the upper limit? The default in the earth package is\n\n\n::: {.cell layout-align=\"center\" hash='cache/eart_0aaa451856e86c8fdc7e0c3f099c8de4'}\n\n```{.r .cell-code}\nmin(200, max(20, 2 * ncol(x))) + 1\n```\n:::\n\n\nwhere `x` is the predictor matrix. We often put in values that are either sensible defaults or are minimal enough to work for the majority of data sets. For now, let's specify an upper limit of 10 but this will be discussed more in the next section.\n\nThe other argument is `trans`, which represents a transformation that should be applied to the parameter values when working with them. For example, many regularization methods have a `penalty` parameter that tends to range between zero and some upper bound (let's say 1). The effect of going from a penalty value of 0.01 to 0.1 is much more impactful than going from 0.9 to 1.0. In such a case, it might make sense to work with this parameter in transformed units (such as the log, in this example). If new parameter values are generated at random, it helps if they are uniformly simulated in the transformed units and then converted back to the original units.\n\nThe `trans` parameter accepts a transformation object from the scales package. For example:\n\n\n::: {.cell layout-align=\"center\" hash='cache/scales_b25ae3bb346dde06d2a7e463ba1f4c4d'}\n\n```{.r .cell-code}\nlibrary(scales)\nlsf.str(\"package:scales\", pattern = \"_trans$\")\n#> asn_trans : function ()  \n#> atanh_trans : function ()  \n#> boxcox_trans : function (p, offset = 0)  \n#> compose_trans : function (...)  \n#> date_trans : function ()  \n#> exp_trans : function (base = exp(1))  \n#> hms_trans : function ()  \n#> identity_trans : function ()  \n#> log_trans : function (base = exp(1))  \n#> log10_trans : function ()  \n#> log1p_trans : function ()  \n#> log2_trans : function ()  \n#> logit_trans : function ()  \n#> modulus_trans : function (p, offset = 1)  \n#> probability_trans : function (distribution, ...)  \n#> probit_trans : function ()  \n#> pseudo_log_trans : function (sigma = 1, base = exp(1))  \n#> reciprocal_trans : function ()  \n#> reverse_trans : function ()  \n#> sqrt_trans : function ()  \n#> time_trans : function (tz = NULL)  \n#> yj_trans : function (p)\nscales::log10_trans()\n#> Transformer: log-10 [1e-100, Inf]\n```\n:::\n\n\nA value of `NULL` means that no transformation should be used.\n\nA quantitative parameter function should have these two arguments and, in the function body, a call `new_quant_param()`. There are a few arguments to this function:\n\n\n::: {.cell layout-align=\"center\" hash='cache/new_quant_param_dc898a8030c6fa2847b68be9c2db5701'}\n\n```{.r .cell-code}\nlibrary(tidymodels)\nargs(new_quant_param)\n#> function (type = c(\"double\", \"integer\"), range = NULL, inclusive = NULL, \n#>     default = deprecated(), trans = NULL, values = NULL, label = NULL, \n#>     finalize = NULL, ..., call = caller_env()) \n#> NULL\n```\n:::\n\n\n-   Possible types are double precision and integers. The value of `type` should agree with the values of `range` in the function definition.\n\n-   It's OK for our tuning to include the minimum or maximum, so we'll use `c(TRUE, TRUE)` for `inclusive`. If the value cannot include one end of the range, set one or both of these values to `FALSE`.\n\n-   The `label` should be a named character string where the name is the parameter name and the value represents what will be printed automatically.\n\n-   `finalize` is an argument that can set parts of the range. This is discussed more below.\n\nHere's an example of a basic quantitative parameter object:\n\n\n::: {.cell layout-align=\"center\" hash='cache/num-initial-terms_d602318800beb1ef90a7bde3e6959438'}\n\n```{.r .cell-code}\nnum_initial_terms <- function(range = c(1L, 10L), trans = NULL) {\n  new_quant_param(\n    type = \"integer\",\n    range = range,\n    inclusive = c(TRUE, TRUE),\n    trans = trans,\n    label = c(num_initial_terms = \"# Initial MARS Terms\"),\n    finalize = NULL\n  )\n}\n\nnum_initial_terms()\n#> # Initial MARS Terms (quantitative)\n#> Range: [1, 10]\n\n# Sample from the parameter:\nset.seed(4832856)\nnum_initial_terms() %>% value_sample(5)\n#> [1]  6  4  9 10  4\n```\n:::\n\n\n### Finalizing parameters\n\nIt might be the case that the range of the parameter is unknown. For example, parameters that are related to the number of columns in a data set cannot be exactly specified in the absence of data. In those cases, a placeholder of `unknown()` can be added. This will force the user to \"finalize\" the parameter object for their particular data set. Let's redefine our function with an `unknown()` value:\n\n\n::: {.cell layout-align=\"center\" hash='cache/num-initial-terms-unk_9de7d72b673760c5098403e4f395b8d8'}\n\n```{.r .cell-code}\nnum_initial_terms <- function(range = c(1L, unknown()), trans = NULL) {\n  new_quant_param(\n    type = \"integer\",\n    range = range,\n    inclusive = c(TRUE, TRUE),\n    trans = trans,\n    label = c(num_initial_terms = \"# Initial MARS Terms\"),\n    finalize = NULL\n  )\n}\nnum_initial_terms()\n\n# Can we sample? \nnum_initial_terms() %>% value_sample(5)\n```\n:::\n\n\nThe `finalize` argument of `num_initial_terms()` can take a function that uses data to set the range. For example, the package already includes a few functions for finalization:\n\n\n::: {.cell layout-align=\"center\" hash='cache/dials-final-funcs_13c8f3f4f0f277ecb3c76d762cb7a32c'}\n\n```{.r .cell-code}\nlsf.str(\"package:dials\", pattern = \"^get_\")\n#> get_batch_sizes : function (object, x, frac = c(1/10, 1/3), ...)  \n#> get_log_p : function (object, x, ...)  \n#> get_n : function (object, x, log_vals = FALSE, ...)  \n#> get_n_frac : function (object, x, log_vals = FALSE, frac = 1/3, ...)  \n#> get_n_frac_range : function (object, x, log_vals = FALSE, frac = c(1/10, 5/10), ...)  \n#> get_p : function (object, x, log_vals = FALSE, ...)  \n#> get_rbf_range : function (object, x, seed = sample.int(10^5, 1), ...)\n```\n:::\n\n\nThese functions generally take a data frame of predictors (in an argument called `x`) and add the range of the parameter object. Using the formula in the earth package, we might use:\n\n\n::: {.cell layout-align=\"center\" hash='cache/earth-range_e1c9bf6b8f535f761d22d3b738ea8bb2'}\n\n```{.r .cell-code}\nget_initial_mars_terms <- function(object, x) {\n  upper_bound <- min(200, max(20, 2 * ncol(x))) + 1\n  upper_bound <- as.integer(upper_bound)\n  bounds <- range_get(object)\n  bounds$upper <- upper_bound\n  range_set(object, bounds)\n}\n\n# Use the mtcars are the finalize the upper bound: \nnum_initial_terms() %>% get_initial_mars_terms(x = mtcars[, -1])\n#> # Initial MARS Terms (quantitative)\n#> Range: [1, 21]\n```\n:::\n\n\nOnce we add this function to the object, the general `finalize()` method can be used:\n\n\n::: {.cell layout-align=\"center\" hash='cache/final-obj_9b8361428190d870490441c3eecf012e'}\n\n```{.r .cell-code}\nnum_initial_terms <- function(range = c(1L, unknown()), trans = NULL) {\n  new_quant_param(\n    type = \"integer\",\n    range = range,\n    inclusive = c(TRUE, TRUE),\n    trans = trans,\n    label = c(num_initial_terms = \"# Initial MARS Terms\"),\n    finalize = get_initial_mars_terms\n  )\n}\n\nnum_initial_terms() %>% finalize(x = mtcars[, -1])\n#> # Initial MARS Terms (quantitative)\n#> Range: [1, 21]\n```\n:::\n\n\n## Qualitative parameters\n\nNow let's look at an example of a qualitative parameter. If a model includes a data aggregation step, we want to allow users to tune how our parameters are aggregated. For example, in embedding methods, possible values might be `min`, `max`, `mean`, `sum`, or to not aggregate at all (\"none\"). Since these cannot be put on a numeric scale, they are possible values of a qualitative parameter. We'll take \"character\" input (not \"logical\"), and we must specify the allowed values. By default we won't aggregate.\n\n\n::: {.cell layout-align=\"center\" hash='cache/aggregation_39f71033809bc19015c698dbeca6311d'}\n\n```{.r .cell-code}\naggregation <- function(values = c(\"none\", \"min\", \"max\", \"mean\", \"sum\")) {\n  new_qual_param(\n    type = \"character\",\n    values = values,\n    # By default, the first value is selected as default. We'll specify that to\n    # make it clear.\n    default = \"none\",\n    label = c(aggregation = \"Aggregation Method\")\n  )\n}\n```\n:::\n\n\nWithin the dials package, the convention is to have the values contained in a separate vector whose name starts with `values_`. For example:\n\n\n::: {.cell layout-align=\"center\" hash='cache/aggregation-vec_7dcc9f145f63cccd19b24d9fa23f4d10'}\n\n```{.r .cell-code}\nvalues_aggregation <- c(\"none\", \"min\", \"max\", \"mean\", \"sum\")\naggregation <- function(values = values_aggregation) {\n  new_qual_param(\n    type = \"character\",\n    values = values,\n    # By default, the first value is selected as default. We'll specify that to\n    # make it clear.\n    default = \"none\",\n    label = c(aggregation = \"Aggregation Method\")\n  )\n}\n```\n:::\n\n\nThis step may not make sense if you are using the function in a script and not keeping it within a package.\n\nWe can use our `aggregation` parameters with dials functions.\n\n\n::: {.cell layout-align=\"center\" hash='cache/aggregation-use_9ac92377d564310ae312bf63617fedad'}\n\n```{.r .cell-code}\naggregation()\n#> Warning: The `default` argument of `new_qual_param()` is deprecated as of\n#> dials 1.1.0.\n#> Aggregation Method  (qualitative)\n#> 5 possible values include:\n#> 'none', 'min', 'max', 'mean' and 'sum'\naggregation() %>% value_sample(3)\n#> [1] \"min\"  \"sum\"  \"mean\"\n```\n:::\n\n\n## Session information {#session-info}\n\n\n::: {.cell layout-align=\"center\" hash='cache/si_43a75b68dcc94565ba13180d7ad26a69'}\n\n```\n#> ─ Session info ─────────────────────────────────────────────────────\n#>  setting  value\n#>  version  R version 4.3.0 (2023-04-21)\n#>  os       macOS Monterey 12.6\n#>  system   aarch64, darwin20\n#>  ui       X11\n#>  language (EN)\n#>  collate  en_US.UTF-8\n#>  ctype    en_US.UTF-8\n#>  tz       America/Los_Angeles\n#>  date     2023-05-25\n#>  pandoc   3.1.1 @ /Applications/RStudio.app/Contents/Resources/app/quarto/bin/tools/ (via rmarkdown)\n#> \n#> ─ Packages ─────────────────────────────────────────────────────────\n#>  package    * version date (UTC) lib source\n#>  broom      * 1.0.4   2023-03-11 [1] CRAN (R 4.3.0)\n#>  dials      * 1.2.0   2023-04-03 [1] CRAN (R 4.3.0)\n#>  dplyr      * 1.1.2   2023-04-20 [1] CRAN (R 4.3.0)\n#>  ggplot2    * 3.4.2   2023-04-03 [1] CRAN (R 4.3.0)\n#>  infer      * 1.0.4   2022-12-02 [1] CRAN (R 4.3.0)\n#>  parsnip    * 1.1.0   2023-04-12 [1] CRAN (R 4.3.0)\n#>  purrr      * 1.0.1   2023-01-10 [1] CRAN (R 4.3.0)\n#>  recipes    * 1.0.6   2023-04-25 [1] CRAN (R 4.3.0)\n#>  rlang        1.1.1   2023-04-28 [1] CRAN (R 4.3.0)\n#>  rsample    * 1.1.1   2022-12-07 [1] CRAN (R 4.3.0)\n#>  scales     * 1.2.1   2022-08-20 [1] CRAN (R 4.3.0)\n#>  tibble     * 3.2.1   2023-03-20 [1] CRAN (R 4.3.0)\n#>  tidymodels * 1.1.0   2023-05-01 [1] CRAN (R 4.3.0)\n#>  tune       * 1.1.1   2023-04-11 [1] CRAN (R 4.3.0)\n#>  workflows  * 1.1.3   2023-02-22 [1] CRAN (R 4.3.0)\n#>  yardstick  * 1.2.0   2023-04-21 [1] CRAN (R 4.3.0)\n#> \n#>  [1] /Users/emilhvitfeldt/Library/R/arm64/4.3/library\n#>  [2] /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/library\n#> \n#> ────────────────────────────────────────────────────────────────────\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
{"title":"Correlation and regression fundamentals with tidy data principles","markdown":{"yaml":{"title":"Correlation and regression fundamentals with tidy data principles","categories":["statistical analysis","correlation","tidying results"],"type":"learn-subsection","weight":1,"description":"Analyze the results of correlation tests and simple regression models for many data sets at once.\n","toc":true,"toc-depth":2,"include-after-body":"../../../resources.html"},"headingText":"Introduction","containsRefs":false,"markdown":"\n\n```{r}\n#| label: \"setup\"\n#| include: false\n#| message: false\n#| warning: false\nsource(here::here(\"common.R\"))\n```\n\n```{r}\n#| label: \"load\"\n#| include: false\nlibrary(tidymodels)\npkgs <- c(\"tidymodels\")\ntheme_set(theme_bw() + theme(legend.position = \"top\"))\n```\n\n\nThis article only requires the tidymodels package.\n\nWhile the tidymodels package [broom](https://broom.tidyverse.org/) is useful for summarizing the result of a single analysis in a consistent format, it is really designed for high-throughput applications, where you must combine results from multiple analyses. These could be subgroups of data, analyses using different models, bootstrap replicates, permutations, and so on. In particular, it plays well with the `nest()/unnest()` functions from [tidyr](https://tidyr.tidyverse.org/) and the `map()` function in [purrr](https://purrr.tidyverse.org/).\n\n## Correlation analysis\n\nLet's demonstrate this with a simple data set, the built-in `Orange`. We start by coercing `Orange` to a `tibble`. This gives a nicer print method that will be especially useful later on when we start working with list-columns.\n\n```{r}\nlibrary(tidymodels)\n\ndata(Orange)\n\nOrange <- as_tibble(Orange)\nOrange\n```\n\nThis contains 35 observations of three variables: `Tree`, `age`, and `circumference`. `Tree` is a factor with five levels describing five trees. As might be expected, age and circumference are correlated:\n\n```{r}\ncor(Orange$age, Orange$circumference)\n\nlibrary(ggplot2)\n\nggplot(Orange, aes(age, circumference, color = Tree)) +\n  geom_line()\n```\n\nSuppose you want to test for correlations individually *within* each tree. You can do this with dplyr's `group_by`:\n\n```{r}\nOrange %>% \n  group_by(Tree) %>%\n  summarize(correlation = cor(age, circumference))\n```\n\n(Note that the correlations are much higher than the aggregated one, and also we can now see the correlation is similar across trees).\n\nSuppose that instead of simply estimating a correlation, we want to perform a hypothesis test with `cor.test()`:\n\n```{r}\nct <- cor.test(Orange$age, Orange$circumference)\nct\n```\n\nThis test output contains multiple values we may be interested in. Some are vectors of length 1, such as the p-value and the estimate, and some are longer, such as the confidence interval. We can get this into a nicely organized tibble using the `tidy()` function:\n\n```{r}\ntidy(ct)\n```\n\nOften, we want to perform multiple tests or fit multiple models, each on a different part of the data. In this case, we recommend a `nest-map-unnest` workflow. For example, suppose we want to perform correlation tests for each different tree. We start by `nest`ing our data based on the group of interest:\n\n```{r}\nnested <- \n  Orange %>% \n  nest(data = c(age, circumference))\n```\n\nThen we perform a correlation test for each nested tibble using `purrr::map()`:\n\n```{r}\nnested %>% \n  mutate(test = map(data, ~ cor.test(.x$age, .x$circumference)))\n```\n\nThis results in a list-column of S3 objects. We want to tidy each of the objects, which we can also do with `map()`.\n\n```{r}\nnested %>% \n  mutate(\n    test = map(data, ~ cor.test(.x$age, .x$circumference)), # S3 list-col\n    tidied = map(test, tidy)\n  ) \n```\n\nFinally, we want to unnest the tidied data frames so we can see the results in a flat tibble. All together, this looks like:\n\n```{r}\nOrange %>% \n  nest(data = c(age, circumference)) %>% \n  mutate(\n    test = map(data, ~ cor.test(.x$age, .x$circumference)), # S3 list-col\n    tidied = map(test, tidy)\n  ) %>% \n  unnest(cols = tidied) %>% \n  select(-data, -test)\n```\n\n## Regression models\n\nThis type of workflow becomes even more useful when applied to regressions. Untidy output for a regression looks like:\n\n```{r}\nlm_fit <- lm(age ~ circumference, data = Orange)\nsummary(lm_fit)\n```\n\nWhen we tidy these results, we get multiple rows of output for each model:\n\n```{r}\ntidy(lm_fit)\n```\n\nNow we can handle multiple regressions at once using exactly the same workflow as before:\n\n```{r}\nOrange %>%\n  nest(data = c(-Tree)) %>% \n  mutate(\n    fit = map(data, ~ lm(age ~ circumference, data = .x)),\n    tidied = map(fit, tidy)\n  ) %>% \n  unnest(tidied) %>% \n  select(-data, -fit)\n```\n\nYou can just as easily use multiple predictors in the regressions, as shown here on the `mtcars` dataset. We nest the data into automatic vs. manual cars (the `am` column), then perform the regression within each nested tibble.\n\n```{r}\ndata(mtcars)\nmtcars <- as_tibble(mtcars)  # to play nicely with list-cols\nmtcars\n\nmtcars %>%\n  nest(data = c(-am)) %>% \n  mutate(\n    fit = map(data, ~ lm(wt ~ mpg + qsec + gear, data = .x)),  # S3 list-col\n    tidied = map(fit, tidy)\n  ) %>% \n  unnest(tidied) %>% \n  select(-data, -fit)\n```\n\nWhat if you want not just the `tidy()` output, but the `augment()` and `glance()` outputs as well, while still performing each regression only once? Since we're using list-columns, we can just fit the model once and use multiple list-columns to store the tidied, glanced and augmented outputs.\n\n```{r}\nregressions <- \n  mtcars %>%\n  nest(data = c(-am)) %>% \n  mutate(\n    fit = map(data, ~ lm(wt ~ mpg + qsec + gear, data = .x)),\n    tidied = map(fit, tidy),\n    glanced = map(fit, glance),\n    augmented = map(fit, augment)\n  )\n\nregressions %>% \n  select(tidied) %>% \n  unnest(tidied)\n\nregressions %>% \n  select(glanced) %>% \n  unnest(glanced)\n\nregressions %>% \n  select(augmented) %>% \n  unnest(augmented)\n```\n\nBy combining the estimates and p-values across all groups into the same tidy data frame (instead of a list of output model objects), a new class of analyses and visualizations becomes straightforward. This includes:\n\n- sorting by p-value or estimate to find the most significant terms across all tests,\n- p-value histograms, and\n- volcano plots comparing p-values to effect size estimates.\n\nIn each of these cases, we can easily filter, facet, or distinguish based on the `term` column. In short, this makes the tools of tidy data analysis available for the *results* of data analysis and models, not just the inputs.\n\n\n## Session information {#session-info}\n\n```{r}\n#| label: \"si\"\n#| echo: false\nsmall_session(pkgs)\n```\n\n","srcMarkdownNoYaml":"\n\n```{r}\n#| label: \"setup\"\n#| include: false\n#| message: false\n#| warning: false\nsource(here::here(\"common.R\"))\n```\n\n```{r}\n#| label: \"load\"\n#| include: false\nlibrary(tidymodels)\npkgs <- c(\"tidymodels\")\ntheme_set(theme_bw() + theme(legend.position = \"top\"))\n```\n\n## Introduction\n\nThis article only requires the tidymodels package.\n\nWhile the tidymodels package [broom](https://broom.tidyverse.org/) is useful for summarizing the result of a single analysis in a consistent format, it is really designed for high-throughput applications, where you must combine results from multiple analyses. These could be subgroups of data, analyses using different models, bootstrap replicates, permutations, and so on. In particular, it plays well with the `nest()/unnest()` functions from [tidyr](https://tidyr.tidyverse.org/) and the `map()` function in [purrr](https://purrr.tidyverse.org/).\n\n## Correlation analysis\n\nLet's demonstrate this with a simple data set, the built-in `Orange`. We start by coercing `Orange` to a `tibble`. This gives a nicer print method that will be especially useful later on when we start working with list-columns.\n\n```{r}\nlibrary(tidymodels)\n\ndata(Orange)\n\nOrange <- as_tibble(Orange)\nOrange\n```\n\nThis contains 35 observations of three variables: `Tree`, `age`, and `circumference`. `Tree` is a factor with five levels describing five trees. As might be expected, age and circumference are correlated:\n\n```{r}\ncor(Orange$age, Orange$circumference)\n\nlibrary(ggplot2)\n\nggplot(Orange, aes(age, circumference, color = Tree)) +\n  geom_line()\n```\n\nSuppose you want to test for correlations individually *within* each tree. You can do this with dplyr's `group_by`:\n\n```{r}\nOrange %>% \n  group_by(Tree) %>%\n  summarize(correlation = cor(age, circumference))\n```\n\n(Note that the correlations are much higher than the aggregated one, and also we can now see the correlation is similar across trees).\n\nSuppose that instead of simply estimating a correlation, we want to perform a hypothesis test with `cor.test()`:\n\n```{r}\nct <- cor.test(Orange$age, Orange$circumference)\nct\n```\n\nThis test output contains multiple values we may be interested in. Some are vectors of length 1, such as the p-value and the estimate, and some are longer, such as the confidence interval. We can get this into a nicely organized tibble using the `tidy()` function:\n\n```{r}\ntidy(ct)\n```\n\nOften, we want to perform multiple tests or fit multiple models, each on a different part of the data. In this case, we recommend a `nest-map-unnest` workflow. For example, suppose we want to perform correlation tests for each different tree. We start by `nest`ing our data based on the group of interest:\n\n```{r}\nnested <- \n  Orange %>% \n  nest(data = c(age, circumference))\n```\n\nThen we perform a correlation test for each nested tibble using `purrr::map()`:\n\n```{r}\nnested %>% \n  mutate(test = map(data, ~ cor.test(.x$age, .x$circumference)))\n```\n\nThis results in a list-column of S3 objects. We want to tidy each of the objects, which we can also do with `map()`.\n\n```{r}\nnested %>% \n  mutate(\n    test = map(data, ~ cor.test(.x$age, .x$circumference)), # S3 list-col\n    tidied = map(test, tidy)\n  ) \n```\n\nFinally, we want to unnest the tidied data frames so we can see the results in a flat tibble. All together, this looks like:\n\n```{r}\nOrange %>% \n  nest(data = c(age, circumference)) %>% \n  mutate(\n    test = map(data, ~ cor.test(.x$age, .x$circumference)), # S3 list-col\n    tidied = map(test, tidy)\n  ) %>% \n  unnest(cols = tidied) %>% \n  select(-data, -test)\n```\n\n## Regression models\n\nThis type of workflow becomes even more useful when applied to regressions. Untidy output for a regression looks like:\n\n```{r}\nlm_fit <- lm(age ~ circumference, data = Orange)\nsummary(lm_fit)\n```\n\nWhen we tidy these results, we get multiple rows of output for each model:\n\n```{r}\ntidy(lm_fit)\n```\n\nNow we can handle multiple regressions at once using exactly the same workflow as before:\n\n```{r}\nOrange %>%\n  nest(data = c(-Tree)) %>% \n  mutate(\n    fit = map(data, ~ lm(age ~ circumference, data = .x)),\n    tidied = map(fit, tidy)\n  ) %>% \n  unnest(tidied) %>% \n  select(-data, -fit)\n```\n\nYou can just as easily use multiple predictors in the regressions, as shown here on the `mtcars` dataset. We nest the data into automatic vs. manual cars (the `am` column), then perform the regression within each nested tibble.\n\n```{r}\ndata(mtcars)\nmtcars <- as_tibble(mtcars)  # to play nicely with list-cols\nmtcars\n\nmtcars %>%\n  nest(data = c(-am)) %>% \n  mutate(\n    fit = map(data, ~ lm(wt ~ mpg + qsec + gear, data = .x)),  # S3 list-col\n    tidied = map(fit, tidy)\n  ) %>% \n  unnest(tidied) %>% \n  select(-data, -fit)\n```\n\nWhat if you want not just the `tidy()` output, but the `augment()` and `glance()` outputs as well, while still performing each regression only once? Since we're using list-columns, we can just fit the model once and use multiple list-columns to store the tidied, glanced and augmented outputs.\n\n```{r}\nregressions <- \n  mtcars %>%\n  nest(data = c(-am)) %>% \n  mutate(\n    fit = map(data, ~ lm(wt ~ mpg + qsec + gear, data = .x)),\n    tidied = map(fit, tidy),\n    glanced = map(fit, glance),\n    augmented = map(fit, augment)\n  )\n\nregressions %>% \n  select(tidied) %>% \n  unnest(tidied)\n\nregressions %>% \n  select(glanced) %>% \n  unnest(glanced)\n\nregressions %>% \n  select(augmented) %>% \n  unnest(augmented)\n```\n\nBy combining the estimates and p-values across all groups into the same tidy data frame (instead of a list of output model objects), a new class of analyses and visualizations becomes straightforward. This includes:\n\n- sorting by p-value or estimate to find the most significant terms across all tests,\n- p-value histograms, and\n- volcano plots comparing p-values to effect size estimates.\n\nIn each of these cases, we can easily filter, facet, or distinguish based on the `term` column. In short, this makes the tools of tidy data analysis available for the *results* of data analysis and models, not just the inputs.\n\n\n## Session information {#session-info}\n\n```{r}\n#| label: \"si\"\n#| echo: false\nsmall_session(pkgs)\n```\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"toc-depth":2,"include-after-body":["../../../resources.html"],"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","notebook-preview-download":"Download Notebook","notebook-preview-back":"Back to Article"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.92","theme":["cosmo","../../../styles.scss","../../../styles-frontpage.scss"],"quarto-required":">= 1.3.353","linestretch":1.6,"grid":{"body-width":"840px"},"title":"Correlation and regression fundamentals with tidy data principles","categories":["statistical analysis","correlation","tidying results"],"type":"learn-subsection","weight":1,"description":"Analyze the results of correlation tests and simple regression models for many data sets at once.\n"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}